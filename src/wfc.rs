use rand::distributions::WeightedIndex;
use rand::prelude::Distribution;
//use colored::Colorize;
use rand::seq::SliceRandom;
use std::collections::HashMap;
use std::hash::Hash;
// use std::env;
use std::ops::Index;
use std::ops::IndexMut;
use std::thread;
use std::{fs::read_dir, fs::File, io::Read};

use rand::thread_rng;

use crate::backgrounds::{
    // CHUNK_HEIGHT, CHUNK_WIDTH,
    MAP_HEIGHT,
    MAP_WIDTH,
};

const MAX_REPICK_ATTEMPTS: usize = 20;

/// Resource to hold game-wide memory-resident information for procedural generation
pub(crate) struct ProcGen {
    /// Rules generated by initial rule generation
    pub(crate) rules: HashMap<usize, Rule>,
    // /// Tile frequencies generated by initial rule generation
    // pub(crate) freqs: HashMap<usize, usize>
}

impl Default for ProcGen {
    fn default() -> Self {
        Self {
            rules: init_rules(),
        }
    }
}

/// Initialize rules by reading every input file in the directory
/// 'assets/backgrounds/wfc_inpits/' and running rulegen on them.
pub(crate) fn init_rules() -> HashMap<usize, Rule> {
    let all_inputs = read_dir("assets/backgrounds/wfc_inputs").unwrap();
    let mut freqs: HashMap<usize, usize> = HashMap::new();
    let mut rules: HashMap<usize, Rule> = HashMap::new();

    // Check all inputs
    for input_file in all_inputs {
        // Run rulegen on the input file given
        rulegen(
            input_file.unwrap().path().to_str().unwrap(),
            &mut rules,
            &mut freqs,
        );
    }

    rules
}
/// Apply rulegeneration to given rule and frequency set based on input read from infile
pub(crate) fn rulegen(
    infile: &str,
    rules: &mut HashMap<usize, Rule>,
    freqs: &mut HashMap<usize, usize>,
) {
    let mut file = File::open(infile).unwrap();
    let mut contents = String::new();
    file.read_to_string(&mut contents).unwrap();

    // Board input is a text file of usize indexes used to map to a tile index in
    // the texture atlas
    // Split file into lines
    let in_board: Vec<Vec<usize>> = contents
        .lines()
        // Split each line by spaces
        .map(|l| {
            l.split(' ')
                // Parse as a usize
                .map(|s| s.parse::<usize>().unwrap())
                // Collect the split line into a single vector
                .collect::<Vec<usize>>()
        })
        // Collect all the line vectors into a 2D vector
        .collect::<Vec<Vec<usize>>>();

    //PASS 1 - GATHER TILE FREQUENCY INFORMATION
    for line in in_board.iter() {
        for col in line.iter() {
            *freqs.entry(*col).or_insert(0) += 1;
        }
    }

    //PASS 2 - GATHER LEGAL NEIGHBOR INFORMATION
    // Iterate over the board in row major order and generate rules
    for (row, line) in in_board.iter().enumerate() {
        for (col, tile_type) in line.iter().enumerate() {
            // Get the adjacency rules for this tile type if they exist,
            // or insert a new adjacency rule map if none exist.
            // The adjacency matrix will be a hashmap mapping from neighbor
            // direction to a vector of allowed tiles for that direction.
            let cur = rules.entry(*tile_type as usize).or_insert(Rule {
                neighbor_rules: HashMap::from([
                    (Dir::WEST, Vec::new()),
                    (Dir::NORTH, Vec::new()),
                    (Dir::EAST, Vec::new()),
                    (Dir::SOUTH, Vec::new()),
                ]),
                freq: freqs[tile_type],
            });

            // Below we actually add the neighbors we see on this iteration to
            // the appropriate rule vector based on the direction of each neighbor
            // NORTH
            row.checked_sub(1)
                .and_then(|r| in_board.get(r))
                .and_then(|c| c.get(col))
                .map(|e| {
                    // Get type of northern neighbor
                    let north_type = *e as usize;
                    // Add this type to the allowed types
                    // if it doesn't already exist there.
                    cur.neighbor_rules.entry(Dir::NORTH).and_modify(|allowed| {
                        if !allowed.contains(&north_type) {
                            allowed.push(north_type);
                        }
                    });

                    // Required by and_then
                    true
                });

            //SOUTH
            row.checked_add(1)
                .and_then(|r| in_board.get(r))
                .and_then(|c| c.get(col))
                .map(|e| {
                    let north_type = *e as usize;
                    cur.neighbor_rules.entry(Dir::SOUTH).and_modify(|allowed| {
                        if !allowed.contains(&north_type) {
                            allowed.push(north_type);
                        }
                    });

                    true
                });

            //WEST
            col.checked_sub(1)
                .and_then(|col| in_board[row].get(col))
                .map(|char| {
                    let north_type = *char as usize;
                    cur.neighbor_rules.entry(Dir::WEST).and_modify(|allowed| {
                        if !allowed.contains(&north_type) {
                            allowed.push(north_type);
                        }
                    });

                    true
                });

            //EAST
            col.checked_add(1)
                .and_then(|col| in_board[row].get(col))
                .map(|char| {
                    let north_type = *char as usize;
                    cur.neighbor_rules.entry(Dir::EAST).and_modify(|allowed| {
                        if !allowed.contains(&north_type) {
                            allowed.push(north_type);
                        }
                    });

                    true
                });
        }
    }

    //println!("rulegen done \n {:?}", rules);
}

/// Generate a fixed (map) sized screen using wave function collapse
/// and return a 2D vector of indexes into the texture atlas.
pub(crate) fn wfc(
    seeding: Option<Vec<(usize, (usize, usize))>>,
    rules: HashMap<usize, Rule>,
) -> Vec<Vec<usize>> {
    // let rules = rulegen("assets/backgrounds/wfc_inputs/input.txt");

    // Create the board with a specific height and width
    // (HEIGHT COMES FIRST because ROW MAJOR order)
    // and the rules and tile types the board will use.
    let mut board = Board::new(
        (MAP_HEIGHT, MAP_WIDTH),
        rules.clone(),
        rules.keys().copied().collect::<Vec<usize>>(),
        seeding.clone(),
    );

    // The result of our WFC operation, what we will want to return.
    let mut result_map: Vec<Vec<usize>> = Vec::new();

    // Let's spawn a new thread to do this with a large amount of stack memory
    // because of how many calls this might make.
    let builder = thread::Builder::new()
        .stack_size(4194304)
        .name("generation thread".to_string());

    // Handler just is so we can join the thread back in
    let handler = builder
        .spawn(move || {
            // Collapse gives us a boolean telling us whether the
            // board is in a collapsable state or if no valid option is available here.
            // This is the core part of WFC. Collapse will modify board to
            // be in a collapsed state, if possible.
            let attempts = 0usize;
            while attempts < MAX_REPICK_ATTEMPTS {
                let solvable = board.collapse(
                    // This choose function picks the tile on the board with the least entropy
                    // (that means the least number of possible states)
                    board.choose_tile_to_collapse(),
                );
                // println!("solved on attempt {attempts}? {solvable:?}");
                // println!("\n");
                if !solvable {
                    board = Board::new(
                        (MAP_HEIGHT, MAP_WIDTH),
                        rules.clone(),
                        rules.keys().copied().collect::<Vec<usize>>(),
                        seeding.clone(),
                    );
                } else {
                    break;
                }

                // attempts += 1;
                // warn!(
                //     "WFC could not collapse. Retrying, attempt {}.",
                //     attempts + 1
                // );
            }

            // Put the board contents into the result
            // so we can return it.
            for row in &board.map {
                let mut result_row: Vec<usize> = Vec::new();
                for c in row {
                    // print!("{}", char::from_u32(c.t.unwrap() as u32).unwrap());
                    // print!("{:02X} ", c.t.unwrap());
                    result_row.push(c.t.unwrap());
                }
                result_map.push(result_row);
                // print!("\n")
            }

            // Return the map we created from the thread
            result_map
        })
        .unwrap();

    // Join thread into parent
    handler.join().unwrap()

    //println!("{:?}", board.map);
}

//TODO: reconsider internalizing the map within this struct.
//because it is a local variable, we cant pass around references to tiles within it without the borrow checker getting mad
//so we instead have to refer to tiles by coords: (usize,usize)
#[derive(Debug, Clone)]
struct Board {
    map: Vec<Vec<Tile>>,
    rules: HashMap<usize, Rule>,
}

impl Index<(usize, usize)> for Board {
    type Output = Tile;

    fn index(&self, index: (usize, usize)) -> &Self::Output {
        &self.map[index.0][index.1]
    }
}

impl IndexMut<(usize, usize)> for Board {
    fn index_mut(&mut self, index: (usize, usize)) -> &mut Self::Output {
        &mut self.map[index.0][index.1]
    }
}

impl Board {
    /// Initialize a board
    fn new(
        size: (usize, usize),
        rules: HashMap<usize, Rule>,
        tile_types: Vec<usize>,
        seeding: Option<Vec<(usize, (usize, usize))>>,
    ) -> Self {
        let mut map: Vec<Vec<Tile>> = Vec::new();

        for row in 0..size.0 {
            map.push(Vec::new());
            for col in 0..size.1 {
                map[row].push(Tile::fresh((row, col), tile_types.clone()));
            }
        }

        if seeding.is_some() {
            for seed in seeding.unwrap() {
                match map.get_mut(seed.1 .0).and_then(|r| r.get_mut(seed.1 .1)) {
                    Some(v) => {
                        *v = Tile::set(v.coords, seed.0);

                        // Collect neighbors by hand, cannot call functions because they are only for
                        // existing boards.
                        let mut n = Neighbors::new();
                        let pos = v.coords;

                        // let north_idx = (pos.0 - 1, pos.1);
                        // let south_idx = (pos.0 + 1, pos.1);
                        // let west_idx = (pos.0, pos.1 - 1);
                        // let east_idx = (pos.0, pos.1 + 1);

                        // North
                        n.north = pos
                            .0
                            .checked_sub(1)
                            .and_then(|e| map.get(e))
                            .map(|f| f[pos.1].clone());

                        // South
                        n.south = pos
                            .0
                            .checked_add(1)
                            .and_then(|e| map.get(e))
                            .map(|f| f[pos.1].clone());

                        // West
                        n.west = pos
                            .1
                            .checked_sub(1)
                            .and_then(|e| map[pos.0].get(e))
                            .cloned();

                        // East
                        n.east = pos
                            .1
                            .checked_add(1)
                            .and_then(|e| map[pos.0].get(e))
                            .cloned();

                        // Do neighbor update
                        for neighbor in n {
                            map[neighbor.tile.coords.0][neighbor.tile.coords.1]
                                .position
                                .retain(|t| {
                                    rules[&seed.0].neighbor_rules[&neighbor.direction].contains(t)
                                });
                        }
                    }
                    None => {}
                }
            }
        }

        Self { map, rules }
    }

    // TODO: Very poor runtime, needs optimization.
    /// This will make sure no tiles on the board are breaking adjacency rules.
    /// It will NOT check if we have a completed board.
    fn valid_position(&self) -> bool {
        for row in &self.map {
            for col in row {
                // Empty superpositions are invalid unless the tile has a concrete type
                if col.position.is_empty() && col.t.is_none() {
                    return false;
                }
            }
        }

        true
    }

    /// Check that the board is in a solved state to stop collapsing early
    fn is_solved(&self) -> bool {
        if !self.valid_position() {
            return false;
        }

        return !self.map.iter().flatten().any(|t| t.t.is_none());
    }

    /// Choose the tile on the board with the lowest entropy and return its coords within the map
    fn choose_tile_to_collapse(&self) -> (usize, usize) {
        // Find the minimum entropy of the board
        let minimum = self
            .map
            .iter()
            .flatten()
            .min_by(|x, y| x.entropy().cmp(&y.entropy()))
            .unwrap()
            .entropy();

        // Collect all tiles into a vector first, we'll operate on this because it's easier
        let mut random_tiles: Vec<&Tile> = self.map.iter().flatten().collect::<Vec<&Tile>>();

        // Retain only tiles with the same entropy as the minimum
        random_tiles.retain(|tile| tile.entropy() == minimum);

        // Shuffle these tiles up in case more than one tile matches
        random_tiles.shuffle(&mut thread_rng());

        // Pick the first of this random ordering
        random_tiles[0].coords
    }

    /// Returns a NEW neighbors struct, with indices into the map of the neighboring tiles
    /// Note that this DOES NOT return references to the ACTUAL neighbors on the maps
    fn get_neighbors(&self, pos: (usize, usize)) -> Neighbors {
        let mut n = Neighbors::new();

        //north
        n.north = pos
            .0
            .checked_sub(1)
            .and_then(|e| self.map.get(e))
            .map(|f| f[pos.1].clone());

        //south
        n.south = pos
            .0
            .checked_add(1)
            .and_then(|e| self.map.get(e))
            .map(|f| f[pos.1].clone());

        //west
        n.west = pos
            .1
            .checked_sub(1)
            .and_then(|e| self.map[pos.0].get(e))
            .cloned();

        //east
        n.east = pos
            .1
            .checked_add(1)
            .and_then(|e| self.map[pos.0].get(e))
            .cloned();

        n
    }

    /// Update the neighbors of this tile to reflect a change in our state.
    ///
    /// Calls a `.retain()` on each neighbor's position to only keep subpositions
    /// that are members of our neighbor-ruleset.
    fn update_neighbors(&mut self, center_tile: (usize, usize), selected_pos: usize) {
        for neighbor in self.get_neighbors(center_tile) {
            // Major issue, this looks like the code to ACTUALLY update the tile's positions in our map,
            // the above only affects a stack allocated tile that is destroyed when the function ends.
            // Yet, when we let the bottom code run, the game crashes almost 50% of the time because it cannot
            // find a valid state. This means that the backtracking algorithm straight up *doesn't work at all.*
            self.map[neighbor.tile.coords.0][neighbor.tile.coords.1]
                .position
                .retain(|t| {
                    self.rules[&selected_pos].neighbor_rules[&neighbor.direction].contains(t)
                });
        }
    }

    /// Takes 1 tile, collapses its state down to a concrete type, and udpates its neighbors' superpositions.
    /// Returns true on success or false on failure.
    fn collapse(&mut self, center_tile: (usize, usize)) -> bool {
        // If our board is already marked as solved, we're done here,
        // jump back up the stack.
        if self.is_solved() {
            return true;
        }

        // info!("collapsing {:?}", center_tile);

        // center_tile is the tile we are pivoting collapse on right now.
        // Get the super position of the tile, back it up,
        // and empty out the position of this tile.

        let mut random_pos = self[center_tile].position.clone();
        let weight_dist =
            WeightedIndex::new(random_pos.iter().map(|pos| self.rules[pos].freq)).unwrap();

        let backup_pos = self[center_tile].position.clone();
        self[center_tile].position = Vec::new();

        // Shuffle up the position and check all of them to find one that is valid.
        // This shuffle gives us the randomality of WFC
        //random_pos.shuffle(&mut thread_rng());

        //for pos in random_pos {
        for _i in 0..random_pos.len() {
            // weight_dist = WeightedIndex::new(random_pos.iter().map(|pos| self.rules[pos].freq)).unwrap();
            let mut pos = backup_pos[weight_dist.sample(&mut thread_rng())];
            while !random_pos.contains(&pos) {
                pos = backup_pos[weight_dist.sample(&mut thread_rng())];
            }
            random_pos.retain(|e| *e != pos);
            // Make sure even our backup doesn't try this again
            // backup_pos.retain(|e| *e != pos);

            // Tentatively give our tile this concrete position
            self[center_tile].t = Some(pos);

            // Backup our neighbors and update neighbors' superpositions
            // according to the current subposition we are trying to collapse
            let old_neighbors = self.get_neighbors(center_tile);
            // Update neighbors' positions
            self.update_neighbors(center_tile, pos);

            // If this subposition is a valid position,
            // call solve on the next tile to be collapse
            if self.valid_position() {
                // if we are not in a solved board, continue recursing, otherwise, return our way up the call stack
                if self.collapse(self.choose_tile_to_collapse()) {
                    return true;
                } else {
                    // Do not return a success if we could not collapse any neighbor
                }
            } else {
                // If we're not in a valid position,
                // set ourselves back to what we were before
                // trying and then we will try the next subpos.
                for n in old_neighbors {
                    self[n.tile.coords] = n.tile.clone();
                }
            }
        }
        // Reset ourselves and fail if no position
        // ever succeeded.
        self[center_tile].t = None;
        self[center_tile].position = backup_pos;
        false
    }
}

#[derive(Debug)]
struct Neighbors {
    north: Option<Tile>,
    south: Option<Tile>,
    east: Option<Tile>,
    west: Option<Tile>,
}

struct NeighborIterElement {
    direction: Dir,
    tile: Tile,
}

impl IntoIterator for Neighbors {
    type Item = NeighborIterElement;
    type IntoIter = std::vec::IntoIter<NeighborIterElement>;

    fn into_iter(self) -> Self::IntoIter {
        let mut neighbors: Vec<NeighborIterElement> = Vec::new();

        if let Some(f) = self.north {
            neighbors.push(NeighborIterElement {
                direction: Dir::NORTH,
                tile: f,
            });
        }

        if let Some(f) = self.south {
            neighbors.push(NeighborIterElement {
                direction: Dir::SOUTH,
                tile: f,
            });
        }

        if let Some(f) = self.east {
            neighbors.push(NeighborIterElement {
                direction: Dir::EAST,
                tile: f,
            });
        }

        if let Some(f) = self.west {
            neighbors.push(NeighborIterElement {
                direction: Dir::WEST,
                tile: f,
            });
        }

        neighbors.into_iter()
    }
}

impl Neighbors {
    fn new() -> Self {
        Self {
            north: None,
            south: None,
            east: None,
            west: None,
        }
    }
}

#[derive(PartialEq, Hash, Eq, Debug, Clone)]
enum Dir {
    WEST,
    NORTH,
    EAST,
    SOUTH,
}

impl IntoIterator for Dir {
    type Item = Dir;
    type IntoIter = std::vec::IntoIter<Dir>;

    fn into_iter(self) -> Self::IntoIter {
        vec![Dir::NORTH, Dir::SOUTH, Dir::EAST, Dir::WEST].into_iter()
    }
}

//this struct defines the rules for a tile type
#[derive(PartialEq, Hash, Eq, Debug, Clone)]
struct Tile {
    coords: (usize, usize),
    //rep: char,
    // Tile only has a type once it has been fully collapsed
    t: Option<usize>,
    position: Vec<usize>,
}
impl Tile {
    /// Create a fresh tile with
    /// a full superposition. Subpositions will be removed
    /// as collapse occurs.
    fn fresh(coords: (usize, usize), full: Vec<usize>) -> Self {
        Self {
            coords,
            t: None,
            position: full,
        }
    }

    fn set(coords: (usize, usize), kind: usize) -> Self {
        Self {
            coords,
            t: Some(kind),
            position: Vec::new(),
        }
    }

    /// Determine what the entropy of the tile is
    ///
    /// Entropy is defined as the number of possible subpositions
    /// in this tile's superposition, or infinity if it is collapsed.
    fn entropy(&self) -> usize {
        if self.t.is_some() {
            usize::MAX
        } else {
            self.position.len()
        }
    }
}

//a rule is information about what is allowed to go on around a tiletype as well as additional information needed for generation such as frequency and symmetry
#[derive(Debug, Clone)]
pub struct Rule {
    neighbor_rules: HashMap<Dir, Vec<usize>>,
    freq: usize,
    //symmetry: add me :)
}

// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣤⣤⣤⣤⣤⣶⣦⣤⣄⡀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⡿⠛⠉⠙⠛⠛⠛⠛⠻⢿⣿⣷⣤⡀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⣼⣿⠋⠀⠀⠀⠀⠀⠀⠀⢀⣀⣀⠈⢻⣿⣿⡄⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⣸⣿⡏⠀⠀⠀⣠⣶⣾⣿⣿⣿⠿⠿⠿⢿⣿⣿⣿⣄⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⣿⣿⠁⠀⠀⢰⣿⣿⣯⠁⠀⠀⠀⠀⠀⠀⠀⠈⠙⢿⣷⡄⠀
// ⠀⠀⣀⣤⣴⣶⣶⣿⡟⠀⠀⠀⢸⣿⣿⣿⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣷⠀
// ⠀⢰⣿⡟⠋⠉⣹⣿⡇⠀⠀⠀⠘⣿⣿⣿⣿⣷⣦⣤⣤⣤⣶⣶⣶⣶⣿⣿⣿⠀
// ⠀⢸⣿⡇⠀⠀⣿⣿⡇⠀⠀⠀⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠃⠀
// ⠀⣸⣿⡇⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠉⠻⠿⣿⣿⣿⣿⡿⠿⠿⠛⢻⣿⡇⠀⠀
// ⠀⣿⣿⠁⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣧⠀⠀
// ⠀⣿⣿⠀⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀
// ⠀⣿⣿⠀⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⠀⠀
// ⠀⢿⣿⡆⠀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⡇⠀⠀
// ⠀⠸⣿⣧⡀⠀⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⠃⠀⠀
// ⠀⠀⠛⢿⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⣰⣿⣿⣷⣶⣶⣶⣶⠶⠀⢠⣿⣿⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀⣿⣿⡇⠀⣽⣿⡏⠁⠀⠀⢸⣿⡇⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⣿⣿⠀⠀⠀⠀⠀⣿⣿⡇⠀⢹⣿⡆⠀⠀⠀⣸⣿⠇⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⢿⣿⣦⣄⣀⣠⣴⣿⣿⠁⠀⠈⠻⣿⣿⣿⣿⡿⠏⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠈⠛⠻⠿⠿⠿⠿⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
